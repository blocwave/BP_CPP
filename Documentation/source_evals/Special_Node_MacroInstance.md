# K2Node_MacroInstance Analysis - Special Node Type

## Overview
K2Node_MacroInstance implements macro expansion by substituting a referenced macro graph in place of the node during compilation. This represents one of the most complex graph transformation operations in Blueprint compilation, requiring complete graph substitution and parameter mapping.

## Key Properties

### Core Configuration
- **MacroGraphReference**: FGraphReference to the macro graph to instantiate
- **ResolvedWildcardType**: FEdGraphPinType storing the resolved type for wildcard pins
- **bReconstructNode**: Flag indicating reconstruction is needed after pin changes

### Inheritance Structure  
```cpp
class UK2Node_MacroInstance : public UK2Node_Tunnel
```

**Key Insight**: Macro instances inherit from tunnel nodes because they create entry/exit points during graph expansion.

## Unique Expansion Patterns

### 1. Graph Substitution Mechanism
```cpp
void AllocateDefaultPins()
{
    UEdGraph* MacroGraph = MacroGraphReference.GetGraph();
    
    // Find tunnel nodes in macro graph to mirror their pins
    for (TArray<UEdGraphNode*>::TIterator NodeIt(MacroGraph->Nodes); NodeIt; ++NodeIt)
    {
        if (UK2Node_Tunnel* TunnelNode = Cast<UK2Node_Tunnel>(*NodeIt))
        {
            // Only exact tunnel nodes (entry/exit points)
            if (TunnelNode->GetClass() == UK2Node_Tunnel::StaticClass())
            {
                for (UEdGraphPin* PortPin : TunnelNode->Pins)
                {
                    if (PortPin->ParentPin == nullptr)
                    {
                        // Create complementary pin (input becomes output, vice versa)
                        UEdGraphPin* NewLocalPin = CreatePin(
                            UEdGraphPin::GetComplementaryDirection(PortPin->Direction), 
                            PortPin->PinType, 
                            PortPin->PinName
                        );
                        Schema->SetPinAutogeneratedDefaultValue(NewLocalPin, PortPin->GetDefaultAsString());
                    }
                }
            }
        }
    }
}
```

### 2. Wildcard Pin Resolution
```cpp
void NotifyPinConnectionListChanged(UEdGraphPin* ChangedPin)
{
    if (ChangedPin->LinkedTo.Num() > 0)
    {
        bool const bIsWildcardPin = ChangedPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard;
        if (bIsWildcardPin)
        {
            FEdGraphPinType const LinkedPinType = ChangedPin->LinkedTo[0]->PinType;

            // Resolve ALL wildcard pins to the same type
            for(int32 PinIdx=0; PinIdx<Pins.Num(); PinIdx++)
            {
                UEdGraphPin* const TmpPin = Pins[PinIdx];
                if (TmpPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
                {
                    TmpPin->PinType.PinCategory = LinkedPinType.PinCategory;
                    TmpPin->PinType.PinSubCategory = LinkedPinType.PinSubCategory;
                    TmpPin->PinType.PinSubCategoryObject = LinkedPinType.PinSubCategoryObject;
                }
            }

            ResolvedWildcardType = LinkedPinType;
            bReconstructNode = true;
        }
    }
}
```

## C++ Code Generation Requirements

### 1. Graph Inlining Strategy
During compilation, macro instances are expanded by:

1. **Graph Copying**: The referenced macro graph is copied into the calling context
2. **Parameter Mapping**: Input/output pins are mapped to local variables
3. **Name Mangling**: Local variables in the macro are prefixed to avoid conflicts
4. **Connection Rewiring**: External connections are redirected to internal nodes

### 2. Generated C++ Pattern
```cpp
// Before macro expansion:
MyMacro(InputParam1, InputParam2, OutputResult);

// After macro expansion (conceptual):
{
    // Local scope for macro variables
    DataType MacroInstance_LocalVar1 = InputParam1;
    DataType MacroInstance_LocalVar2 = InputParam2;
    
    // Inlined macro logic
    DataType MacroInstance_TempResult = MacroInstance_LocalVar1 + MacroInstance_LocalVar2;
    // ... more macro logic ...
    
    // Output assignment
    OutputResult = MacroInstance_TempResult;
}
```

### 3. Variable Scoping Implementation
```cpp
// Each macro instance gets unique variable names:
FString VariablePrefix = FString::Printf(TEXT("MacroInstance_%s_%d_"), 
                                       *MacroGraph->GetName(), 
                                       GetUniqueID());

// All local variables in the macro are prefixed:
// "LocalVar" becomes "MacroInstance_ForLoop_1234_LocalVar"
```

## Special Properties Not In Base K2Node

### 1. Cross-Blueprint Dependency Management
```cpp
bool HasExternalDependencies(TArray<class UStruct*>* OptionalOutput) const
{
    UBlueprint* OtherBlueprint = MacroGraphReference.GetBlueprint();
    const bool bResult = OtherBlueprint && (OtherBlueprint != GetBlueprint());
    
    if (bResult && OptionalOutput)
    {
        // Add the macro blueprint as a dependency
        OptionalOutput->AddUnique(*OtherBlueprint->GeneratedClass);
        
        // Add dependencies from pin types
        for (UEdGraphPin* Pin : Pins)
        {
            if (Pin->PinType.PinSubCategoryObject.IsValid())
            {
                OptionalOutput->AddUnique(Pin->PinType.PinSubCategoryObject.Get());
            }
        }
    }
}
```

### 2. Macro Library Validation  
```cpp
bool CanPasteHere(const UEdGraph* TargetGraph) const
{
    UBlueprint* MacroBlueprint  = GetSourceBlueprint();
    UBlueprint* TargetBlueprint = FBlueprintEditorUtils::FindBlueprintForGraph(TargetGraph);

    // Only allow local macros or library macros with compatible parent classes
    bool bCanPaste = (MacroBlueprint == TargetBlueprint) || 
                     (MacroBlueprint->BlueprintType == BPTYPE_MacroLibrary &&
                      TargetBlueprint->ParentClass->IsChildOf(MacroBlueprint->ParentClass));

    // Prevent recursive macro inclusion
    UEdGraph* MacroGraph = GetMacroGraph();
    bCanPaste &= (MacroGraph != TargetGraph);
    
    // Prevent latent macros in function graphs
    bool const bIsTargetFuncGraph = (TargetGraph->GetSchema()->GetGraphType(TargetGraph) == GT_Function);
    bCanPaste &= (!bIsTargetFuncGraph || !FBlueprintEditorUtils::CheckIfGraphHasLatentFunctions(MacroGraph));
}
```

### 3. Metadata Preservation
```cpp
static FKismetUserDeclaredFunctionMetadata* GetAssociatedGraphMetadata(const UEdGraph* AssociatedMacroGraph)
{
    // Find the entry tunnel node to get metadata
    TArray<UK2Node_Tunnel*> TunnelNodes;
    AssociatedMacroGraph->GetNodesOfClass(TunnelNodes);

    for (UK2Node_Tunnel* Node : TunnelNodes)
    {
        if (Node->IsEditable() && Node->bCanHaveOutputs)
        {
            return &(Node->MetaData); // Tooltip, category, color, etc.
        }
    }
    return nullptr;
}
```

## Edge Cases and Validation Requirements

### 1. Wildcard Pin Consistency
```cpp
void PostFixupAllWildcardPins(bool bInAllWildcardPinsUnlinked)
{
    if (bInAllWildcardPinsUnlinked)
    {
        // Reset wildcard type when all connections are broken
        ResolvedWildcardType.ResetToDefaults();

        // Collapse split pins back to wildcards
        for (UEdGraphPin* Pin : WildcardPins)
        {
            GetSchema()->RecombinePin(Pin);
            Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
            Pin->PinType.PinSubCategory = NAME_None;
            Pin->PinType.PinSubCategoryObject = nullptr;
        }
    }
}
```

### 2. Macro Library Asset Loading
```cpp
void PreloadRequiredAssets()
{
    PreloadObject(MacroGraphReference.GetBlueprint());
    UEdGraph* MacroGraph = MacroGraphReference.GetGraph();
    PreloadObject(MacroGraph);
    
    // Ensure macro graph is fully loaded before pin allocation
    if (MacroGraph->HasAnyFlags(RF_NeedLoad))
    {
        PreloadObject(MacroGraph);
        FBlueprintEditorUtils::PreloadMembers(MacroGraph);
    }
}
```

### 3. Recursive Reference Prevention
```cpp
// Macros cannot reference themselves directly or indirectly
bool ValidateMacroReference()
{
    TSet<UEdGraph*> VisitedGraphs;
    return CheckForCircularReference(GetMacroGraph(), VisitedGraphs);
}
```

## Blueprint to C++ Conversion Considerations

### 1. Macro Expansion Strategy
- **Inline Expansion**: Replace macro call with expanded graph content
- **Function Call**: Convert to C++ function call (for reusable macros)
- **Template Instantiation**: Use C++ templates for generic macros

### 2. Variable Scoping
```cpp
// Option 1: Lambda scope isolation
auto MacroExpansion = [&]() {
    // Expanded macro content
    LocalType MacroVar = InputParam;
    return ProcessMacroLogic(MacroVar);
};
Result = MacroExpansion();

// Option 2: Block scope isolation  
{
    LocalType MacroVar = InputParam;
    Result = ProcessMacroLogic(MacroVar);
}
```

### 3. Template Macro Conversion
```cpp
// Blueprint macro with wildcards becomes C++ template
template<typename T>
T MyGenericMacro(T Input1, T Input2)
{
    // Expanded macro logic
    return Input1 + Input2;
}
```

## Implementation Priority
**CRITICAL** - Macro instances represent ~25% of all Blueprint functionality in typical projects. They enable code reuse and are fundamental to Blueprint modularity. Complex expansion patterns make this essential for complete conversion.

## Dependencies
- UK2Node_Tunnel (base class)
- FGraphReference (macro graph referencing)
- FKismetUserDeclaredFunctionMetadata (macro metadata)
- Blueprint dependency tracking system
- Wildcard pin resolution system